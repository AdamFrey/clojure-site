= Destructuring in Clojure
Michael Zavarella
2015-12-9
:jbake-type: page
:toc: macro

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

=== What is Destructuring?

Destructuring is a way to concisely bind names to the values in a data structure. It allows us to remove some of the bulk when working with large data structures. Destructuring allows us to write more concise and readable code.

Consider the following example of extracting and naming values in a vector.

[source,clojure]
----
(def my-line [[5 10] [10 20]])

(let [p1 (first my-line)
       p2 (second my-line)
       x1 (first p1)
       y1 (second p1)
       x2 (first p2)
       y2 (second p2)]
  (println "Line from (" x1 "," y1 ") to (" x2 ", " y2 ")"))
 ;= "Line from ( 5 , 10 ) to ( 10 , 20 )"
----

This is perfectly valid, but the code extracting and naming the values in the vector obsucring our intent. Destructuring allows us to concisely extract and name important parts of complex data structures to make our code cleaner.

[source,clojure]
----
;= Using the same vector as above
(let [[p1 p2] my-line
      [x1 y1] p1
      [x2 y2] p2]
 (println "Line from (" x1 "," y1 ") to (" x2 ", " y2 ")"))
;= "Line from ( 5 , 10 ) to ( 10 , 20 )"
----

Rather than explictly binding each variable, we describe the bindings based on their sequential order. That's a pretty weird statement, "describe the bindings," so let's look at it again.

We have a data structure `my-line` that looks like this, `[[5 10] [10 20]]`. In our destructuring form we will create a vector containing two elements, `p1` and `p2`, each of which are vectors themselves. This will bind the vector `[5 10]` to the symbol `p1` and the vector `[10 20]` to the symbol `p2`. Since we want to work with the elements of `p1` and `p2` rather than the structures themselves, we destructure `p1` and `p2` within the same let statement. The vector `p1` looks like this, `[5 10]`, so to destructure it, we create a vector containing two elements, `x1` and `y1`. This binds `5` to the symbol `x1` and `10` to the symbol `y1`. The same is repeated for `p2` binding `10` to `x2` and `20` to `y2`. At this point, we now have everything we need to work with our data.

=== Sequential Destructuring

Clojure destructuring is broken up into two categories, sequential destructuring and associative destructuring. Sequential destructuring represents a sequential data structure as a Clojure vector within a let binding.

This type of destructuring can be used on any kind of data structure that can be traversed in linear time. That includes anything from Clojure

[source,clojure]
----
(def my-vector [1 2 3])
(def my-list '(1 2 3))
(def my-string "abc")

;= It should come as no surprise that this will print out 1 2 3
(let [[x y z] my-vector]
  (println x y z))
;= 1 2 3

;= We can also use a similar technique to destructure a list
(let [[x y z] my-list]
  (println x y z))
;= 1 2 3

;= For strings, the elements are destructured by character.
(let [[x y z] my-string]
  (do
    (println x y z)
    (map type [x y z])))
;= a b c
;= (java.lang.Character java.lang.Character java.lang.Character)
----

The key to seuqential destructuring is that you bind the values one-by-one to the symbols of a vector. For instance the vector `[x y z]` will match each element one-by-one with the list `'(1 2 3)`.

In some cases, the collection you are destructuring isn't the exact same size as the destructuring bindings. If the vector is too small, the extra symbols will be bound to nil.

[source,clojure]
----
(def small-list '(1 2 3))
(let [[a b c d e f g] small-list]
  (println a b c d e f g))
;= 1 2 3 nil nil nil nil
----

On the other hand, if the collection is too large, the extra values are simply ignored.

[source,clojure]
----
(def large-list '(1 2 3 4 5 6 7 8 9 10))
(let [[a b c] large-list]
  (println a b c)
;= 1 2 3
----

Destructuring gives you total control over the elements that you choose to bind (or not) and how you bind them.

Many times, you don't need access to _every_ element in a collection, only certain ones.

[source,clojure]
----
(def names ["Michael" "Amber" "Aaron" "Nick" "Earl" "Joe"])
----

Say you want to print the first element on one line and the remainder on another line.

[source,clojure]
----
(let [[first second third fourth fifth sixth] names]
  (do
    (println first)
    (println second third fourth fifth sixth)))
;= Michael
;= Amber Aaron Nick Earl Joe
----

This binding works but even using destructuring it's pretty clunky. Here we can use `&` to clump the tail elements into a sequence.

[source,clojure]
----
(let [[first & remaining] names]
  (do
    (println first)
    (println remaining)))
;= Michael
;= Amber Aaron Nick Earl Joe
----

You can ignore bindings that you don't intend on using by binding them to any symbol of your choosing.

[source,clojure]
----
(let [[first _ third _ fifth _] names]
  (println "Odd names:" first third fifth))
;= Odd names: Michael Aaron Earl
----

The convention for this is to use an underscore like above.

You can use `:as all` to bind the entire vector to the symbol `all`.

[source,clojure]
----
(let [[first :as all] names]
  (println "The first name from" all "is" first))
;= The first name from [Michael Amber Aaron Nick Earl Joe] is Michael
----

Let's stop for a bit and look a little further into the types of `:as` and `&`.

[source,clojure]
----
(def numbers [1 2 3 4 5])
(let [[x & rest :as all] numbers]
  (apply prn [rest all]))
;= (2 3 4 5) [1 2 3 4 5]
----

So rest is bound to a `sequence` containing the remaining elements of the `numbers` vector while `all` has been bound to the original `vector`. What happens when we destructure a string instead?

[source,clojure]
----
(def word "Clojure")
(let [[x & rest :as all] word]
  (apply prn [x rest all]))
;= \C (\l \o \j \u \r \e) "Clojure"
----

How this works is, bound to `all` is the original structure (String, vector, list, whatever it may be). Bound to `x` is the character `\C`. And bound to `rest` is the list of characters remaining.



You can combine any or all of these techniques at the same time at your discretion.

[source,clojure]
----
(def fruits ["apple" "orange" "strawberry" "peach" "pear" "lemon"])
(let [[first _ third & rest :as all-fruits] fruits]
  (do
    (println "The first and thir fruits are," first "and" third)
    (println "These we're taken from" all-fruits)
    (println "The fruits after them are" rest))
;= The first and third fruits are, apple and strawberry
;= These we're taken from [apple orange strawberry peach pear lemon]
;= The fruits after them are (peache pear lemon)
----

Destructuring grants you access to vectors nested within vectors as well. Let's go back to our vector from the very beginning, `my-line`.

[source,clojure]
----
(def my-line [[5 10] [10 20]])
----

This vector is comprised of nested vectors that we can access directly.

[source,clojure]
----
(let [[[x1 y1][x2 y2]] my-line]
  (println "Line from (" x1 "," y1 ") to (" x2 ", " y2 ")"))
;= "Line from ( 5 , 10 ) to ( 10 , 20 )"
----

While you can penetrate through as many layers as you need, once you get to the fourth or fifth layer this becomes difficult to read.

When you have nested vectors, you can use `:as` to bind the whole nested vector to a single symbol.

[source,clojure]
----
(let [[[a b :as first] [c d :as second]] my-line]
  (do
    (println a b first)
    (println c d second)))
;= 1 2 [1 2]
;= 3 4 [3 4]
----

=== Associative Destructuring

Syntax: `[{symbol-1 :key-a, symbol-2 :key-b} {:key-a "value a" :key-b "value b"}]`

Associative destructuring is the same idea as sequential destructuring but instead of binding symbols element-by-element, you bind them using keys.

Associative destructuring works on:
1. Clojure maps, sets, and vectors
2. Anything that the `get` function operates on.
3. Hmm...

[source,clojure]
----
(def my-map {:a "A" :b "B" :c 3 :d 4})

(let [{a :a b :b c :c d :d} my-map]
  (println a b c d))
;= A B 3 4
----

The first thing that should stand out to you here is that the destructuring form is no longer a vector, rather it is a map, hence the name associative destructuring.
The second thing that should stand out is that there are symbols _and_ keywords within the destructuring form. Associative destructuring binds the elements of a map to symbols using the map's keys.

Both types of destructuring act very similarly. If you try to bind a symbol to a key that doesn't exist, you get nil.

[source,clojure]
----
(let [{a :a x :x} my-map]
  (println a x))
;= A nil
----

Associative destructuring allows you to replace all of the nil values with a default value.

[source,clojure]
----
(let [{a :a, x :x, :or {x "X not found!" y "Y not found!" z "Z not found!"}} my-map]
  (println x y z))
;= X not found! Y not found! Z not found!
----

You aren't required to bind any keys that you don't want to bind, just like sequential destructuring.

[source,clojure]
----
(let [{a :a _ :b c :c _ :d} my-map]
  (println a c))
;= A 3
----

Since associative destructuring isn't sequential, it is more common practice to simply leave out the keys that you aren't planning on using. This prevents the destructuring form from becoming too crowded.

[source,clojure]
----
(let [{a :a c :c} my-map]
  (println a c))
;= A 3
----

If you need access to the entire map, you can use the `:as all` shortcut like in sequential destructuring.

[source,clojure]
----
(let [{a :a :as all} my-map]
  (println "I got" A "from" all))
;= I got A from {:a "A" :b "B" :c 3 :d 4}
----

The `:as` and `:or` keywords can be combined in a single destructuring.

[source,clojure]
----
(let [{a :a x :x, :or {x "Not found!"}, :as all} my-map]
  (do
    (println "I got" A "from" all)
    (println "Where is x?" x))
;= I got A from {:a "A" :b "B" :c 3 :d 4}
;= Where is x? Not found!
----

You might have noticed the amount of redundant information in these associative destructuring forms. For each key we've been using, we're just renaming them to their corresponding symbol, making the form a little muddled. This is no good, redundant data is never a good thing. To resolve this, you can use the `:keys` shortcut.

[source,clojure]
----
(let [{:keys [a c]} my-map]
  (println a c))
;= A 3
----

You can also use `:strs` and `syms` if the keys in the map aren't actually keywords.

[source,clojure]
----
(def string-keys {"a" "A" "b" "B"})

(let [{:strs [a b]} string-keys]
  (println a b))
;= A B

(def symbol-keys {'a "A" 'b "B"})

(let [{:syms [a b]} symbol-keys]
  (println ab))
;= A B
----

You get the same output with a much more concise and readable input.

We've been consistently binding keys to their corresponding symbol, `:a` to `a` and `:b` to `b`. You aren't limited to this practice though. You are free to bind the values to whatever symbols you choose.

[source,clojure]
----
(let [{first :a third :c} my-map]
  (println first third))
;= A 3
----

Associative destructuring also supports nested maps, similarly to sequential destructuring.

[source,clojure]
----
(def nested-map {:a {:d 1} :b 2 :c 3})
(let [{{a :d} :a, b :b, c :c} nested-map]
  (println a b c))
;= 1 2 3

(def deeply-nested-maps {:a {:c [1 2]} :b {:d {:e 3}}})

(let [{{[a b] :c} :a, {{c :e} :d} :b} deeply-nested-maps]
  (println a b c))
;= 1 2 3
----

Associative destrucuturing also works with lists since they support key value pairs.

[source,clojure]
----
(def key-list '("A", "B", :c "C", :d "D"))
(let [a b & {:keys [c d]} key-list]
  (pintln a b c d))
;= A B C D
----

=== Where to destructure

You can utilize destructuring anywhere that there is an explicit or implicit let binding.

==== Function Declarations

Passing a collection of information into a function is common practice in Clojure, so the ability to separate those parameters' information is important. When you define a function in Clojure you can utilize destructuring to make the function definition very concise.

Here we have the standard let x equal this, let y equal that, etc... Again, this is perfectly valid code, it's just verbose.

[source,clojure]
----
(defn print-coordinates-1 [point]
  (let [x (first point)
        y (second point)
        z (last point)]
    (println "x:" x ", y:" y ", z:" z)))
----

So we can implement destructuring by using a let within the function. This is much nicer than the first try, but we can still do better.

[source,clojure]
----
(defn print-coordinates-2 [point]
  (let [[x y z] point]
    (println "x:" x ", y:" y ", z:" z)))
----

When defining a function in clojure, there is an implicit `let` binding used on the parameters in order to create the local scope of the function. We can leverage this to whittle our function definition down even more.

[source,clojure]
----
(defn print-coordinates-3 [[x y z]]
  (println "x:" x ", y:" y ", z:" z))
----

That cut the definition down to be less than half of what it was to get the same output.

[source,clojure]
----
(print-coordinates-1 [10 50 30])
;= "x: 10, y: 50, z: 30"

(print-coordinates-2 [10 50 30])
;= "x: 10, y: 50, z: 30"

(print-coordinates-3 [10 50 30])
;= "x: 10, y: 50, z: 30"
----

For a more realistic example, let's create a map containing some basic contact information for the infamous John Smith.

[source,clojure]
----
(def john-smith {:f-name "John"
                 :l-name "Smith"
                 :phone "2150041776"
                 :company "Functional Industries"
                 :title "Sith Lord of Git"})
----

So here we have John's personal information and now we need to access the values within this more-than-trivial map.

[source,clojure]
----
(defn print-contact-info [{:keys [f-name l-name phone company title]}]
  (do
    (println f-name l-name "is the" title "at" company)
    (println "You can reach him at" phone)))

(print-contact-info john-smith)
;= John Smith is the Sith Lord of Git at Functional Industries
;= You can reach him at 2150041776
----

This function will associatevly destructure the the input using the `:keys` shortcut and then print out the contact information that we provided.

What are we thinking though!? It's 2015, no one uses their cell phones we all hand write personal letters to be delivered via the speedy Pony Express!

[source,clojure]
----
(def john-smith {:f-name "John"
                 :l-name "Smith"
                 :phone "2150041776"
                 :address {:street "452 Lisp Ln."
                           :city "Macroville"
                           :state "Kentucky"
                           :zip "81321"}
                 :company "Functional Industries"
                 :title "Sith Lord of Git"})
----

We have an address in there now, but we needed to nest a map into our original structure in order to accomplish this.

[source,clojure]
----
(defn print-contact-info [{:keys [f-name l-name phone company title]
                            {:keys [street city state zip]} :address}]
  (do
    (println f-name l-name "is the" title "at" company)
    (println "You can reach him at" phone)
    (println "He lives at" street city state zip)))

(print-contact-info john-smith)
;= John Smith is the Sith Lord of Git at Functional Industries
;= You can reach him at 2150041776
;= He lives at 452 Lisp Ln. Macroville Kentucky 81321
----
