= Destructuring in Clojure
Michael Zavarella
2015-12-9
:jbake-type: page
:toc: macro

ifdef::env-github,env-browser[:outfilesuffix: .adoc]

=== What is Destructuring?

For someone new to Clojure, the idea of destructuring might be difficult to grasp. Simply put, destructuring is a way to concisely bind names to the values in a data structure. It allows us to remove some of the bulk when working with large data structures. Destructuring allows us to write more concise and readable code.

[source,clojure]
----
(def my-vector [10 5 8 30])
----

[source,clojure]
----
(let [x (first my-vector)
      y (second my-vector)
      z (nth my-vector 4)
      a (last my-vector)]
  ; And now we can use x, y, and z
  (println "x:" x ", y:" y ", z:" z ", a:" a))
;;= "x: 10, y: 5, z: 8, a: 30"
----

This isn't bad code, in fact it's perfectly valid, it's just a bit bulky. Once you start to work with larger data structures, this technique will become very cumbersome. With destructuring you can pull apart data structures much more concisely.

[source,clojure]
----
;; Using the same vector as above
(let [[x y z a] my-vector]
  (println "x: " x ", y: " y ", z: " z ", a:" a))
;;= "x: 10, y: 5, z: 8, a: 30"
----

Rather than explictly binding each variable, we describe the shape of the data to create the bindings. That's a pretty weird statement, "describe the shape," so let's look at it again.

We have a data structure `my-vector` that looks like this, `[10 5 8]`. The shape of `my-vector` can be described as a `vector` containing `3` `elements` of type `java.lang.Long`. In our destructuring form we will create a `vector` of `3` elements to mimick the shape of `my-vector` like so, `[x y z]`. So in this let statement, we are binding `[x y z]` to `[10 5 8]`, one element at a time, or as we call it, sequentially.

=== Sequential Destructuring

Clojure destructuring is broken up into two categories, sequential destructuring and associative destructuring. Seuqential destructuring represents a sequenctial data structure as a Clojure vector within a let binding.

This type of destructuring can be used on anything from Clojure lists, strings, and vectors to Java Lists and ArrayLists. Anything that the `nth` function can operate on, sequential destructuring can be applied to.

[source,clojure]
----
(def my-vector [1 2 3])
(def my-list '(1 2 3))
(def my-string "abc")

;; It should come as no surprise that this will print out 1 2 3
(let [[x y z] my-vector]
  (println x y z))
;;= 1 2 3

;; We can also use a similar technique to destructure a list
(let [[x y z] my-list]
  (println x y z))
;;= 1 2 3

;; For strings, the elements are destructured by character.
(let [[x y z] my-string]
  (do
    (println x y z)
    (map type [x y z])))
;;= a b c
;;= (java.lang.Character java.lang.Character java.lang.Character)
----

The key to seuqential destructuring is that you bind the values one-by-one to the symbols of a vector. For instance the vector `[x y z]` will match each element one-by-one with the list `'(1 2 3)`.

In some cases, the collection you are destructuring isn't the exact same size as the destructuring bindings. If the vector is too small, the extra symbols will be bound to nil.

[source,clojure]
----
(def small-list '(1 2 3))
(let [[a b c d e f g] small-list]
  (println a b c d e f g))
;;= 1 2 3 nil nil nil nil
----

On the other hand, if the collection is too large, the extra values are simply ignored.

[source,clojure]
----
(def large-list '(1 2 3 4 5 6 7 8 9 10))
(let [[a b c] large-list]
  (println a b c)
;;= 1 2 3
----

Destructuring gives you total control over the elements that you choose to bind (or not) and how you bind them.

Many times, you don't need access to _every_ element in a collection, only certain ones.

[source,clojure]
----
(def names ["Michael" "Amber" "Aaron" "Nick" "Earl" "Joe"])
----

Say you want to print the first element on one line and the remainder on another line.

[source,clojure]
----
(let [[first second third fourth fifth sixth] names]
  (do
    (println first)
    (println second third fourth fifth sixth)))
;;= Michael
;;= Amber Aaron Nick Earl Joe
----

This binding works but even using destructuring it's pretty clunky. Here we can use `&` to clump the tail elements into a sequence.

[source,clojure]
----
(let [[first & remaining] names]
  (do
    (println first)
    (println remaining)))
;;= Michael
;;= Amber Aaron Nick Earl Joe
----

Using the `_` you can ignore bindings that you don't intend on using.

[source,clojure]
----
(let [[first _ third _ fifth _] names]
  (println "Odd names:" first third fifth))
;;= Odd names: Michael Aaron Earl
----

You can use `:as all` to bind the entire vector to the symbol `all`.

[source,clojure]
----
(let [[first :as all] names]
  (println "The first name from" all "is" first))
;;= The first name from [Michael Amber Aaron Nick Earl Joe] is Michael
----

Let's stop for a bit and look a little further into the types of `:as` and `&`.

[source,clojure]
----
(def numbers [1 2 3 4 5])
(let [[x & rest :as all] numbers]
  (apply println [rest all]))
;;= (2 3 4 5)
;;= [1 2 3 4 5]
----

So rest is bound to a `sequence` containing the remaining elements of the `numbers` vector while `all` has been bound to the original `vector`. What happens when we destructure a string instead?

[source,clojure]
----
(def word "Clojure")
(let [[x & rest :as all]]
  (apply println [rest all]))
;;= (l o j u r e)
;;= Clojure
----

How it works is, all is bound to the original structure, whether it be a string, vector, Java ArrayList, etc... While bound to `rest` is a sequence, in this case, of characters, in the example above it is of integers.

You can combine any or all of these techniques at the same time at your discretion.

[source,clojure]
----
(def fruits ["apple" "orange" "strawberry" "peach" "pear" "lemon"])
(let [[first _ third & rest :as all-fruits] fruits]
  (do
    (println "The first and thir fruits are," first "and" third)
    (println "These we're taken from" all-fruits)
    (println "The fruits after them are" rest))
;;= The first and third fruits are, apple and strawberry
;;= These we're taken from [apple orange strawberry peach pear lemon]
;;= The fruits after them are (peache pear lemon)
----

Destructuring grants you access to vectors nested within vectors as well. While you can penitrate through as many layers as you need, once you get to the fourth or fifth layer this becomes difficult to read.

[source,clojure]
----
(def nested-vector [1 [2 [3 [4 [5]]]]])

(let [a [b [c [d [e]]]]]
  (println a b c d e))
;;= 1 2 3 4 5
----

When you have nested vectors, you can use `:as` to bind the whole nested vector to a single symbol.

[source,clojure]
----
(let [[[a b :as first] [c d :as second]] nested-vector]
  (do
    (println a b first)
    (println c d second)))
;;= 1 2 [1 2]
;;= 3 4 [3 4]
----

=== Associative Destructuring

Syntax: `[{symbol-1 :key-a, symbol-2 :key-b} {:key-a "value a" :key-b "value b"}]`

Associative destructuring is the same idea as sequential destructuring but instead of binding symbols element-by-element, you bind them using keys.

Associative destructuring works on:
1. Clojure maps, sets, and vectors
2. Anything that the `get` function operates on.
3. Hmm...

[source,clojure]
----
(def my-map {:a "A" :b "B" :c 3 :d 4})

(let [{a :a b :b c :c d :d} my-map]
  (println a b c d))
;;= A B 3 4
----

The first thing that should stand out to you here is that the destructuring form is no longer a vector, rather it is a map, hence the name associative destructuring.
The second thing that should stand out is that there are symbols _and_ keywords within the destructuring form. Associative destructuring binds the elements of a map to symbols using the map's keys.

Both types of destructuring act very similarly. If you try to bind a symbol to a key that doesn't exist, you get nil.

[source,clojure]
----
(let [{a :a x :x} my-map]
  (println a x))
;;= A nil
----

Associative destructuring allows you to replace all of the nil values with a default value.

[source,clojure]
----
(let [{a :a, x :x, :or {x "X not found!" y "Y not found!" z "Z not found!"}} my-map]
  (println x y z))
;;= X not found! Y not found! Z not found!
----

You aren't required to bind any keys that you don't want to bind, just like sequential destructuring.

[source,clojure]
----
(let [{a :a _ :b c :c _ :d} my-map]
  (println a c))
;;= A 3
----

Since associative destructuring isn't sequential, it is more common practice to simply leave out the keys that you aren't planning on using. This prevents the destructuring form from becoming too crowded.

[source,clojure]
----
(let [{a :a c :c} my-map]
  (println a c))
;;= A 3
----

If you need access to the entire map, you can use the `:as all` shortcut like in sequential destructuring.

[source,clojure]
----
(let [{a :a :as all} my-map]
  (println "I got" A "from" all))
;;= I got A from {:a "A" :b "B" :c 3 :d 4}
----

The `:as` and `:or` keywords can be combined in a single destructuring.

[source,clojure]
----
(let [{a :a x :x, :or {x "Not found!"}, :as all} my-map]
  (do
    (println "I got" A "from" all)
    (println "Where is x?" x))
;;= I got A from {:a "A" :b "B" :c 3 :d 4}
;;= Where is x? Not found!
----

You might have noticed the amount of redundant information in these associative destructuring forms. For each key we've been using, we're just renaming them to their corresponding symbol, making the form a little muddled. This is no good, redundant data is never a good thing. To resolve this, you can use the `:keys` shortcut.

[source,clojure]
----
(let [{:keys [a c]} my-map]
  (println a c))
;;= A 3
----

You can also use `:strs` and `syms` if the keys in the map aren't actually keywords.

[source,clojure]
----
(def string-keys {"a" "A" "b" "B"})

(let [{:strs [a b]} string-keys]
  (println a b))
;;= A B

(def symbol-keys {'a "A" 'b "B"})

(let [{:syms [a b]} symbol-keys]
  (println ab))
;;= A B
----

You get the same output with a much more concise and readable input.

We've been consistently binding keys to their corresponding symbol, `:a` to `a` and `:b` to `b`. You aren't limited to this practice though. You are free to bind the values to whatever symbols you choose.

[source,clojure]
----
(let [{first :a third :c} my-map]
  (println first third))
;;= A 3
----

Associative destructuring also supports nested maps, similarly to sequential destructuring.

[source,clojure]
----
(def nested-map {:a {:d 1} :b 2 :c 3})
(let [{{a :d} :a, b :b, c :c} nested-map]
  (println a b c))
;;= 1 2 3

(def deeply-nested-maps {:a {:c [1 2]} :b {:d {:e 3}}})

(let [{{[a b] :c} :a, {{c :e} :d} :b} deeply-nested-maps]
  (println a b c))
;;= 1 2 3
----

Associative destrucuturing also works with lists since they support key value pairs.

[source,clojure]
----
(def key-list '("A", "B", :c "C", :d "D"))
(let [a b & {:keys [c d]} key-list]
  (pintln a b c d))
;;= A B C D
----

=== Where to destructure

You can utilize destructuring anywhere that there is an explicit or implicit let binding.

==== Function Declarations

Passing a collection of information into a function is common practice in Clojure, so the ability to separate those parameters' information is important. When you define a function in Clojure you can utilize destructuring to make the function definition very concise.

Here we have the standard let x equal this, let y equal that, etc... Again, this is perfectly valid code, it's just verbose.

[source,clojure]
----
(defn print-coordinates-1 [point]
  (let [x (first point)
        y (second point)
        z (last point)]
    (println "x:" x ", y:" y ", z:" z)))
----

So we can implement destructuring by using a let within the function. This is much nicer than the first try, but we can still do better.

[source,clojure]
----
(defn print-coordinates-2 [point]
  (let [[x y z] point]
    (println "x:" x ", y:" y ", z:" z)))
----

When defining a function in clojure, there is an implicit `let` binding used on the parameters in order to create the local scope of the function. We can leverage this to whittle our function definition down even more.

[source,clojure]
----
(defn print-coordinates-3 [[x y z]]
  (println "x:" x ", y:" y ", z:" z))
----

That cut the definition down to be less than half of what it was to get the same output.

[source,clojure]
----
(print-coordinates-1 [10 50 30])
;;= "x: 10, y: 50, z: 30"

(print-coordinates-2 [10 50 30])
;;= "x: 10, y: 50, z: 30"

(print-coordinates-3 [10 50 30])
;;= "x: 10, y: 50, z: 30"
----

For a more realistic example, let's create a map containing some basic contact information for the infamous John Smith.

[source,clojure]
----
(def john-smith {:f-name "John"
                 :l-name "Smith"
                 :phone "2150041776"
                 :company "Functional Industries"
                 :title "Sith Lord of Git"})
----

So here we have John's personal information and now we need to access the values within this more-than-trivial map.

[source,clojure]
----
(defn print-contact-info [{:keys [f-name l-name phone company title]}]
  (do
    (println f-name l-name "is the" title "at" company)
    (println "You can reach him at" phone)))

(print-contact-info john-smith)
;;= John Smith is the Sith Lord of Git at Functional Industries
;;= You can reach him at 2150041776
----

This function will associatevly destructure the the input using the `:keys` shortcut and then print out the contact information that we provided.

What are we thinking though!? It's 2015, no one uses their cell phones we all hand write personal letters to be delivered via the speedy Pony Express!

[source,clojure]
----
(def john-smith {:f-name "John"
                 :l-name "Smith"
                 :phone "2150041776"
                 :address {:street "452 Lisp Ln."
                           :city "Macroville"
                           :state "Kentucky"
                           :zip "81321"}
                 :company "Functional Industries"
                 :title "Sith Lord of Git"})
----

We have an address in there now, but we needed to nest a map into our original structure in order to accomplish this.

[source,clojure]
----
(defn print-contact-info [{:keys [f-name l-name phone company title]
                            {:keys [street city state zip]} :address}]
  (do
    (println f-name l-name "is the" title "at" company)
    (println "You can reach him at" phone)
    (println "He lives at" street city state zip)))

(print-contact-info john-smith)
;;= John Smith is the Sith Lord of Git at Functional Industries
;;= You can reach him at 2150041776
;;= He lives at 452 Lisp Ln. Macroville Kentucky 81321
----
